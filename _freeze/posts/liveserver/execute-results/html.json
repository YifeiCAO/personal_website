{
  "hash": "f9a7786b6d4853c514ee7522d20df1ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to achieve the Visual Studio Code 'Live Server' extension in Doom Emacs\"\ndescription: \"Some reflections on how I configured Doom to locally host a site\"\nauthor: \"Luke\"\ndate: \"07/22/2024\"\ncategories:\n  - emacs\n  - webdev\n  - software\nimage: \"images/doom.png\"\ncomments:\n    utterances:\n      repo: lukmayer/site_comments\n      theme: github-dark\n      issue-term: url\ndraft: true\n---\n\n\n\n\nHello again :)\n\nLately, I have been venturing into the depths of Emacs, a 40+ year old text editor that is still very much alive and kicking, adored by many. It's something that I have been meaning to learn for a while as I'm someone who likes to customize their tools.\nI have to admit though, it took me at least three separate attempts until I finally broke through the initial learning curve. In retrospect, learning Vim and Emacs is actually quite simple (even when done at the same time), neither is particularly hard to understand.\nI'm certainly not expert in either, but after experimenting with both for no more than a few months now I feel as though I understand both well enough to complete most of my daily tasks. Besides not knowing the keybindings to do anything in the beginning, I think the main reason it was such an overwhelming beginner experience for me actually comes down to the fact that you need to build up your configuration, which is done in Elisp. I initially experimented with vanilla Emacs but found the configuration so overwhelming that I gave up. I then tried Spacemacs, a supposedly \"newbie-friendly\" distribution of Emacs, just to be bombarded with about a gazillion error messages on start up! It's fair to say that I did not use that for long either. Finally, I decided to give Doom Emacs, another modern distribution of Emcas, a try. Despite being targeted at advanced users, I found it to be by far the most beginner-friendly to use. Again, that is because in Doom Emacs, the configuration is pretty straightforward. There is a pre-made set of packages you can turn on and off, which cover most basic use-cases, and installing additional packages is as simple as adding one line to the packages.el file. \n\nSo this is again where I actually start writing about the thing that this post is meant to be about. When I was still using VS Code, it was quite convenient to do web-development because of the Live Server extension that allows you to render the files in your directory inside your browser. So in essence you can play around with this preview of your code.\nThis is probably a trivial task to most experienced developers who had to achieve similar functionality way before modern IDE's came along. But for me, and probably many coders of my generation and ability level who learned how to code while taking the high level abstractions given by modern development tools for granted, leaving these pre-configured extensions behind and looking even just slightly behind the scenes can seem a bit daunting. \n\nSo here I was, an almost total Emacs newbie having set out to glimpse behind the curtain and slowly build up my configuration of Doom Emacs for my development purposes, wanting something similar to \"live server\" in the much more familiar VS Code. As it turns out, achieving virtually the same functionality in Doom Emacs, was only slightly less trivial than in VS Code. In case you're not aware, being a piece of extensible software that has been actively developed for over 40 years has its advantages. Basically, there is a package for pretty much anything. Sure, on the one hand that means you need to double check whether the particular package you're looking to use is still being maintained, but generally speaking, there is a package for basically anything you can think of. You might be thinking this whole extension business sounds a lot like VS Code and you would not be wrong with that, but the beauty of it all really is that Emacs is \"hackable\" whereas VS Code is merely \"considerably extendable\". I don't plan on discussing the detailed implications of this terminology as its probably deserving of its own post so I'll finish this paragraph with a paraphrased quote (I can't find the original anymore) to highlight the point: \"VS Code is a web-browser that can edit text files, Emacs is a text editor that can browse the web\".\n\nSo how did I actually do it? Essentially its as simple as defining a custom function that calls some other functions from packages I installed. I'll show you the code below, but first I'll explain what it does. The code below sets up a local server on port 8080, and then opens the browser to the root directory of the server. The server is set to serve the files in the directory you specify in the httpd-root variable. The impatient-mode package is a package that allows you to see the changes you make to your html files in real time in the browser. So when you open an html file in Emacs, it will automatically open in the browser and any changes you make to the file will be reflected in the browser.\n\nIn case you're a newbie like me and have not yet found someone elses code to use, feel free to copy this for your config.el! Don't forget to install the packages simple-httpd and impatient-mode first. You can do this by adding them to the packages.el file in your Doom Emacs configuration and then running the command `doom sync` in your terminal. Enjoy :)\n\n\\\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(message \"Setting up live-server\")\n;; Load simple-httpd and impatient-mode\n(use-package simple-httpd\n  :config\n  (setq httpd-root \"~/public_html\") ; set your desired root directory\n  (setq httpd-port 8080))\n\n(use-package impatient-mode\n  :hook (html-mode . impatient-mode)\n  :config\n  (defun my/start-httpd-and-impatient-mode ()\n    \"Start httpd and impatient-mode, then open the browser.\"\n    (interactive)\n    (httpd-start)\n    (impatient-mode)\n    (browse-url \"http://localhost:8080/imp/\"))\n\n  (defun my/impatient-mode-hook ()\n    (my/start-httpd-and-impatient-mode))\n\n  (add-hook 'html-mode-hook 'my/impatient-mode-hook))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}